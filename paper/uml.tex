\documentclass{jsarticle}

\begin{document}
\title{依存関係をもつファイルの変更時間への影響分析}
\author{上田裕己\thanks{島根大学}}
\date{}
\maketitle

\section{まえがき}
大規模なソフトウェア開発では多くのファイルからソフトウェアが成り立っている.
そのため,あるファイルを変更した場合ほかのファイルにも影響を及ぼす.

本研究では,変更されたソースコードの依存関係の依存の向きに着目して,依存関係をもつファイルが次に変更されるまでの期間への影響を調査した.
  結果から変更されているソースコードに依存しているソースコードほど次に変更されるまでの期間が短くなることが分かった.
  
キーワード　ソフトウェアリポジトリマイニング, オープンソース開発, ソースコード変更, バグ修正, 依存関係, 保守

\section{研究背景・目的} 
しかし，対象ファイル群が依存する他のファイル群（以降，依存ファイル群）に対する専門レベルは考慮されていない．これは，依存ファイルと依存関係にあるファイルに対して十分な検査が行えず，不具合を見逃す恐れがある．

本論文では変更されたファイルに対して依存関係のあるファイルが変更されるのにかかる時間への影響を分析する.

\section{関連研究}
既存研究では依存関係のあるファイルが影響を受けることが分かっている.


\section{調査方法}
以下の項目について調査を行う.
\begin{itemize}
\item RQ1:依存関係の種類によるコードファイルの変更時間
\item RQ2:変更する人物の傾向
\item RQ3:マージされたコミットの傾向
\end{itemize}


以下の手順でコードを解析を行う.
\begin{enumerate}
\item プロジェクトの状態を一つ過去のものに戻す.
\item プロジェクトの情報をdoxygenで生成する
\item 生成されたXMLファイルから依存関係を求める.
\item 依存関係のあるファイルの情報をcsvファイルに出力する.
\item 過去の変更がなくなるまで１に戻る
\item データから傾向を解析する
\end{enumerate}


\subsection{バージョン管理システム}
バージョン管理システムとはファイルの変更の履歴を保存するためのシステムである.
現在多くのソフトウェアではバージョンコントロール管理システムが利用されている.
GitHubなどの分散型のバージョン管理システムでは,多くの開発者が一つのソフトウェアを変更していても,


\subsection{RQ1:依存関係の種類によるコードファイルの変更時間}

\subsubsection{調査対象のデータセット}
GitHub上のeclipseプロジェクトの中で最もstar数が多かったものを選んだ.
vert.vプロジェクトを調査,2013年から2016年まで変更され続け,合計2000以上のコミットが行われている.
eclipseプロジェクトには多くのオープンソースソフトウェアがあり,今後ほかのプロジェクトと比較するのに適していると考えた.

\subsubsection{doxygen}
コードの情報についてXML形式で出力するツール.
本研究ではvertプロジェクトで利用されているjavaで書かれたソースコードを解析するのに利用した.

\subsubsection{コードの依存関係解析}
生成されたXMLファイルから依存しているファイル・依存されているファイルの絶対パスを調べる


\subsubsection{出力するデータセット}
csv形式で時系列とともに出力する.
出力するデータは以下のとおりである.

\begin{tabular}{|l|r|r|} \hline
属性名 & 概要 \\ \hline
filepass & ファイルの絶対パス \\ \hline
commitNo & HEADからのコミットの距離 \\ \hline
date & 変更が行われた日付 \\ \hline
author & 変更を行った開発者の名前 \\ \hline
kind & 依存関係の種類 \\ \hline
ismerge & マージされた後のコミットであるかどうか \\ \hline
\end{tabular}

これらの情報をもとにさらにデータを追加する.
以下は上のデータをもとに算出するデータである.
\begin{tabular}{|l|r|r|} \hline
属性名 & 概要 \\ \hline
SubDate & 依存関係が発生してから次に変更されるまでの日にち \\ \hline
SubCommitNo & 依存関係が発生してから次に変更されるまでのコミット数 \\ \hline
\end{tabular}

\begin{enumerate}
\item root 変更されたファイル
\item depender rootが依存するファイル
\item dependee rootが依存されるファイル
\item depender2 dependerが依存するファイル
\item dependee2 dependeeが依存されるファイル
\item other 上記に当てはまらないファイル
\end{enumerate}

\subsection{RQ2:変更する人物の傾向}
依存関係をもつファイルを同じ開発者が変更した場合,どのような依存関係が開発の期間に影響を受けるか調査した.


\subsection{RQ3:マージされたコミットの傾向}
一度分岐した変更が統合された場合も変更の一つとされている.
この



\section{実験結果}
\subsection{RQ1:依存関係の種類によるコードファイルの変更時間}
依存関係別,またmergeされたかどうかによって依存関係を持つファイルが次に変更されるまでの日にち,コミット数を出力した.
図　は依存関係別にみた依存関係の検出から変更されるまでの日数を箱ひげ図で出力したものである.　　

図　は依存関係別にみた依存関係の検出から変更されるまでのコミット回数を箱ひげ図で出力したものである.

dependeeやdependee2からわかるように変更されたファイルに依存しているファイルが早く変更される傾向にあることが分かった.
すべてのファイルの変更されるまでの日付の中央値は２５日なのに対してdependeeは約５日で変更される.

p-valueを求めた結果それぞれ優位差があることがわかる.


\subsection{RQ2変更する人物の傾向}
あるファイルが変更されてからそのファイルと依存関係をもつファイルが次に変更されるのが何日後になるのか,それぞれの依存関係ごとに調査しその統計を取った.

同じ人物が変更した場合と比較し,違う人物が変更したファイルは全体的に中央値が高い結果になっている.
depender2とotherを比較した場合,違い人物が変更した場合には大きな差がないのに対して,同じ人物が変更した場合は20日近く差があることが分かった.



\section{考察}
dpendeeが早い段階で影響を受けていることが分かった.

otherと比較し,依存関係のあるファイルはそうでないファイルと比較して早い段階で変更されることがわかる.

mergeされたコミットの場合mergeされていないコミットと比較して次に変更される時期が遅くなる傾向がある.
以下はその理由を考察してみた.
\begin{enumerate}
\item レビューを通してから変更を適用するために信頼性が高く,変更の必要がなくなる
\item mergeされ終わり, 作業が減るから
\item 変更を行ったのがコアコミッターではないため不具合があったとしても修正に時間がかかる
\end{enumerate}

特に依存されているファイルに依存されているファイルであるdepender2はotherと中央値が同じ数値を出している,
\begin{enumerate}
\item 外部からの変更ではあまり抽象的になりがちなファイルを変更しづらい
\item 絶対数が少ないため, 変更されにくい
\end{enumerate}



\section{まとめ} 
本研究では,ファイルの依存関係が位階の変更にどのような時間の影響を受けるか調査した.
その結果,依存されているファイルほど変更されにくいことが分かった.
この結果からレビューを行っていない変更の場合は特に依存関係に注意をする必要がある.
今回は一つのプロジェクトのみを調査した.ほかのプロジェクトでも同じような傾向がみられるか調査する必要がある.



\begin{thebibliography}{10}
  \bibitem{Balachandram}
    V. Balachandran: Reducing Human Effort and Improving Quality in Peer Code Reviews using Automatic Static Analysis and Reviewer Recommendation, ICSE'13, pp. 931-940, 2013.
  \bibitem{Thongtanunam}
    Patanamon Thongtanunam, Chakkrit Tantithamthavorn, Raula Gaikovina Kula, Norihiro Yoshida, Hajimu Iida, Ken-ichi Matsumoto: Who Should Review My Code? A File Location-Based Code-Reviewer Recommendation Approach for Modern Code Review, 22nd IEEE International Conference on Software Analysis, Evolution, and Reengineering, 2015.
  \bibitem{Thongtanunam2}
    Patanamon Thongtanunam and Shane McIntosh and Ahmed E. Hassan and Hajimu Iida: Revisiting Code Ownership and Its Relationship with Software Quality in the Scope of Modern Code Review, Proc. of the International Conference on Software Engineering (ICSE), 2016
 \end{thebibliography}

\end{document}
